// Copyright 2025 Recall Contributors
// SPDX-License-Identifier: Apache-2.0, MIT

//! Wallet pool management for tests.
//!
//! This module provides a pool of test wallets that can be used in integration tests
//! to avoid conflicts when multiple tests need to interact with the blockchain.
//! The wallets are loaded from a JSON file generated by the scripts/start-recall.sh script.

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::OnceLock;

/// A test wallet with address and private key
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestWallet {
    /// The wallet address (Ethereum format)
    pub address: String,
    /// The private key (hex encoded with 0x prefix)
    pub private_key: String,
}

/// Global wallet pool instance
static WALLET_POOL: OnceLock<WalletPool> = OnceLock::new();

/// Pool of test wallets for concurrent test execution
pub struct WalletPool {
    /// All available test wallets
    wallets: Vec<TestWallet>,
    /// Counter for round-robin distribution
    counter: AtomicUsize,
}

impl WalletPool {
    /// Load wallets from the test-wallets.json file
    fn load_wallets() -> Result<Vec<TestWallet>> {
        let wallet_file = Path::new("test-wallets.json");

        if !wallet_file.exists() {
            anyhow::bail!(
                "test-wallets.json not found. This file should be in the repository root."
            );
        }

        let content =
            fs::read_to_string(wallet_file).context("Failed to read test-wallets.json")?;

        let wallets: Vec<TestWallet> =
            serde_json::from_str(&content).context("Failed to parse test-wallets.json")?;

        if wallets.is_empty() {
            anyhow::bail!("No wallets found in test-wallets.json");
        }

        Ok(wallets)
    }

    /// Create a new wallet pool
    fn new() -> Result<Self> {
        let wallets = Self::load_wallets()?;
        Ok(Self {
            wallets,
            counter: AtomicUsize::new(0),
        })
    }

    /// Get the global wallet pool instance
    pub fn instance() -> &'static WalletPool {
        WALLET_POOL.get_or_init(|| WalletPool::new().expect("Failed to initialize wallet pool"))
    }

    /// Get the next available wallet from the pool
    ///
    /// This uses a simple round-robin strategy to distribute wallets.
    /// Each call returns a different wallet until all wallets have been used,
    /// then it cycles back to the first wallet.
    pub fn get_next_wallet(&self) -> TestWallet {
        let index = self.counter.fetch_add(1, Ordering::Relaxed) % self.wallets.len();
        self.wallets[index].clone()
    }

    /// Get a specific wallet by index
    ///
    /// Returns None if the index is out of bounds
    #[allow(dead_code)]
    pub fn get_wallet_by_index(&self, index: usize) -> Option<TestWallet> {
        self.wallets.get(index).cloned()
    }

    /// Get the total number of wallets in the pool
    pub fn wallet_count(&self) -> usize {
        self.wallets.len()
    }

    /// Get all wallets in the pool
    ///
    /// Useful for tests that need to iterate over all wallets
    pub fn all_wallets(&self) -> Vec<TestWallet> {
        self.wallets.clone()
    }
}

/// Get the next available test wallet
///
/// This is a convenience function that gets a wallet from the global pool.
pub fn get_next_wallet() -> TestWallet {
    WalletPool::instance().get_next_wallet()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wallet_pool_round_robin() {
        let pool = WalletPool::instance();
        let wallet_count = pool.wallet_count();

        // Get wallets in sequence
        let mut wallets = Vec::new();
        for _ in 0..wallet_count {
            wallets.push(pool.get_next_wallet());
        }

        // Next wallet should be the same as the first
        let next_wallet = pool.get_next_wallet();
        assert_eq!(next_wallet.address, wallets[0].address);
    }

    #[test]
    fn test_wallet_pool_concurrent_access() {
        use std::thread;

        let pool = WalletPool::instance();
        let wallet_count = pool.wallet_count();

        // Spawn multiple threads that get wallets
        let handles: Vec<_> = (0..10)
            .map(|_| thread::spawn(move || get_next_wallet()))
            .collect();

        // Collect results
        let wallets: Vec<_> = handles.into_iter().map(|h| h.join().unwrap()).collect();

        // We should have gotten different wallets (modulo the pool size)
        assert_eq!(wallets.len(), 10);

        // Check that we're cycling through wallets properly
        for (i, wallet) in wallets.iter().enumerate() {
            let expected_index = i % wallet_count;
            if let Some(_expected_wallet) = pool.get_wallet_by_index(expected_index) {
                // Note: This might not match exactly due to concurrent access,
                // but we can at least verify all wallets are valid
                assert!(pool
                    .all_wallets()
                    .iter()
                    .any(|w| w.address == wallet.address));
            }
        }
    }
}
