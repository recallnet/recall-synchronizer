// Copyright 2025 Recall Contributors
// SPDX-License-Identifier: Apache-2.0, MIT

//! Wallet pool management for tests.
//!
//! This module provides a pool of test wallets that can be used in integration tests
//! to avoid conflicts when multiple tests need to interact with the blockchain.
//! The wallets are loaded from a JSON file generated by the scripts/recall-start.sh script.

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::OnceLock;

/// A test wallet with address and private key
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestWallet {
    /// The wallet address (Ethereum format)
    pub address: String,
    /// The private key (hex encoded with 0x prefix)
    pub private_key: String,
}

/// Global wallet pool instance
static WALLET_POOL: OnceLock<WalletPool> = OnceLock::new();

/// Pool of test wallets for concurrent test execution
pub struct WalletPool {
    /// All available test wallets
    wallets: Vec<TestWallet>,
    /// Counter for round-robin distribution
    counter: AtomicUsize,
}

impl WalletPool {
    /// Load wallets from the test-wallets.json file
    fn load_wallets() -> Result<Vec<TestWallet>> {
        let wallet_file = Path::new("test-wallets.json");

        if !wallet_file.exists() {
            anyhow::bail!(
                "test-wallets.json not found. This file should be in the repository root."
            );
        }

        let content =
            fs::read_to_string(wallet_file).context("Failed to read test-wallets.json")?;

        let wallets: Vec<TestWallet> =
            serde_json::from_str(&content).context("Failed to parse test-wallets.json")?;

        if wallets.is_empty() {
            anyhow::bail!("No wallets found in test-wallets.json");
        }

        Ok(wallets)
    }

    /// Create a new wallet pool
    fn new() -> Result<Self> {
        let wallets = Self::load_wallets()?;
        Ok(Self {
            wallets,
            counter: AtomicUsize::new(0),
        })
    }

    /// Get the global wallet pool instance
    pub fn instance() -> &'static WalletPool {
        WALLET_POOL.get_or_init(|| WalletPool::new().expect("Failed to initialize wallet pool"))
    }

    /// Get the next available wallet from the pool
    ///
    /// This uses a simple round-robin strategy to distribute wallets.
    /// Each call returns a different wallet until all wallets have been used,
    /// then it cycles back to the first wallet.
    pub fn get_next_wallet(&self) -> TestWallet {
        let index = self.counter.fetch_add(1, Ordering::Relaxed) % self.wallets.len();
        self.wallets[index].clone()
    }
}

/// Get the next available test wallet
///
/// This is a convenience function that gets a wallet from the global pool.
pub fn get_next_wallet() -> TestWallet {
    WalletPool::instance().get_next_wallet()
}
